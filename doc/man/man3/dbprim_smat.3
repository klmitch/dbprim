.TH "Sparse matrices" 3 "31 Aug 2003" "Database Primitives Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Sparse matrices \- 
.SH "DETAILED DESCRIPTION"
.PP 
Sparse matrices are advanced data structures used to represent associations. For instance, a manager may have several employees, but several of those employees may report to more than one manager. (Yes, this is a contrived example, so sue me.) The simplest way to represent such assocations is with a matrix, or a two-dimensional array. However, such an implementation cannot easily be extended dynamically--imagine if a manager retires and two more are hired, for instance. It would also use an enormous amount of memory, as most employees would only report to one or two managers.
.PP
A sparse matrix solves this problem by only allocating memory for the cells in the full matrix which are actually used. That is, no memory is allocated to represent Alice reporting to Bob unless Alice actually does report to Bob. This is a simple concept, but fairly difficult to implement efficiently--how do you tell if Alice reports to Bob? The solution utilized by this library is to combine the strengths of linked lists and hash tables. Each cell is in two linked lists, rooted at the rows and columns of the matrix, but a hash table is used when attempting to look up a given cell. If the cell is allocated, then there will be an entry in the hash table, and finding the given cell is as fast as a hash table look-up.
.PP
Because sparse matrices are so complicated, there are three structures and a variety of operations used. Two of the structures, \fBsmat_table_t\fP and \fBsmat_head_t\fP, are caller-allocated. However, the third structure, \fBsmat_entry_t\fP, must be allocated by the library. To avoid too much overhead from malloc(), a free list is used. The free list may be managed with the \fBsmat_cleanup()\fP and \fBsmat_freemem()\fP calls.
.PP
The \fBsmat_table_t\fP contains the hash table. Only one of these need be allocated per type of association--for instance, in the above example, only one \fBsmat_table_t\fP needs to be allocated to represent the manager-employee relationship.
.PP
The \fBsmat_head_t\fP contains the linked list. There are actually two kinds of these structures--one is \fBSMAT_LOC_FIRST\fP, which could be regarded as a ``row,'' and the other is \fBSMAT_LOC_SECOND\fP, which could be regarded as a ``column.'' Which one is used for which type of data is irrelevant, as long as consistency is maintained. For the above example, a \fBsmat_head_t\fP for a manager may be \fBSMAT_LOC_FIRST\fP, and one for an employee must then be \fBSMAT_LOC_SECOND\fP. (These values are set when initializing the \fBsmat_head_t\fP structure.)
.PP
An association may be created with the \fBst_add()\fP function, which allows an arbitrary ordering in the associated linked lists by the same mechanism as for the linked list component of the library. An association may be removed with \fBst_remove()\fP, or looked up with \fBst_find()\fP. If iteration over all associations is desired, use the \fBst_iter()\fP function. Removing all associations from a table may be performed with \fBst_flush()\fP, which optionally calls a user-defined clean-up function. The associated hash table may be resized with \fBst_resize()\fP, and the bucket table may be released with \fBst_free()\fP.
.PP
An association may also be reordered within the linked lists using the \fBsh_move()\fP function. If a particular entry is desired, use the \fBsh_find()\fP function with a user-defined comparison function to locate it. Iteration may be performed with the \fBsh_iter()\fP function, and all entries in a given linked list may be removed with the sh_flush() function, which again may optionally call a user-defined clean-up function. 
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBSMAT_TABLE_INIT\fP(flags, resize, extra)"
.br
.RI "\fISparse matrix table static initializer.\fP"
.ti -1c
.RI "#define \fBst_verify\fP(table)"
.br
.RI "\fISparse matrix table verification macro.\fP"
.ti -1c
.RI "#define \fBst_flags\fP(table)"
.br
.RI "\fISparse matrix table flags.\fP"
.ti -1c
.RI "#define \fBst_frozen\fP(table)"
.br
.RI "\fIDetermine if a sparse matrix is frozen.\fP"
.ti -1c
.RI "#define \fBst_modulus\fP(table)"
.br
.RI "\fISparse matrix table modulus.\fP"
.ti -1c
.RI "#define \fBst_count\fP(table)"
.br
.RI "\fISparse matrix table count.\fP"
.ti -1c
.RI "#define \fBst_extra\fP(table)"
.br
.RI "\fIExtra pointer data in a sparse matrix table.\fP"
.ti -1c
.RI "#define \fBst_size\fP(table)"
.br
.RI "\fISparse matrix table memory size.\fP"
.ti -1c
.RI "#define \fBSMAT_HEAD_INIT\fP(elem, object)"
.br
.RI "\fISparse matrix list head static initializer.\fP"
.ti -1c
.RI "#define \fBsh_verify\fP(head)"
.br
.RI "\fISparse matrix list head verification macro.\fP"
.ti -1c
.RI "#define \fBsh_elem\fP(head)"
.br
.RI "\fISparse matrix list head element macro.\fP"
.ti -1c
.RI "#define \fBsh_table\fP(head)"
.br
.RI "\fISparse matrix list head table pointer.\fP"
.ti -1c
.RI "#define \fBsh_frozen\fP(head)"
.br
.RI "\fIDetermine if a sparse matrix is frozen.\fP"
.ti -1c
.RI "#define \fBsh_count\fP(head)"
.br
.RI "\fISparse matrix list count.\fP"
.ti -1c
.RI "#define \fBsh_first\fP(head)"
.br
.RI "\fIFirst element in sparse matrix list.\fP"
.ti -1c
.RI "#define \fBsh_last\fP(head)"
.br
.RI "\fILast element in sparse matrix list.\fP"
.ti -1c
.RI "#define \fBsh_object\fP(head)"
.br
.RI "\fIObject represented by a sparse matrix list head.\fP"
.ti -1c
.RI "#define \fBsh_size\fP(head)"
.br
.RI "\fISparse matrix list memory size.\fP"
.ti -1c
.RI "#define \fBse_verify\fP(entry)"
.br
.RI "\fISparse matrix entry verification macro.\fP"
.ti -1c
.RI "#define \fBse_table\fP(entry)"
.br
.RI "\fISparse matrix entry table.\fP"
.ti -1c
.RI "#define \fBse_flags\fP(entry)"
.br
.RI "\fISparse matrix entry flags.\fP"
.ti -1c
.RI "#define \fBse_hash\fP(entry)"
.br
.RI "\fISparse matrix table entry hash value.\fP"
.ti -1c
.RI "#define \fBse_next\fP(entry, n)"
.br
.RI "\fINext element in sparse matrix list.\fP"
.ti -1c
.RI "#define \fBse_prev\fP(entry, n)"
.br
.RI "\fIPrevious element in sparse matrix list.\fP"
.ti -1c
.RI "#define \fBse_lflags\fP(entry, n)"
.br
.RI "\fIFlags associated with an entry in a sparse matrix list.\fP"
.ti -1c
.RI "#define \fBse_object\fP(entry, n)"
.br
.RI "\fIObject associated with an entry in a sparse matrix list.\fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef _smat_table_s \fBsmat_table_t\fP"
.br
.RI "\fISparse matrix table.\fP"
.ti -1c
.RI "typedef _smat_head_s \fBsmat_head_t\fP"
.br
.RI "\fISparse matrix list head.\fP"
.ti -1c
.RI "typedef _smat_entry_s \fBsmat_entry_t\fP"
.br
.RI "\fISparse matrix entry.\fP"
.ti -1c
.RI "typedef unsigned long(* \fBsmat_resize_t\fP )(\fBsmat_table_t\fP *, unsigned long)"
.br
.RI "\fISparse matrix table resize callback.\fP"
.ti -1c
.RI "typedef unsigned long(* \fBsmat_iter_t\fP )(\fBsmat_table_t\fP *, \fBsmat_entry_t\fP *, void *)"
.br
.RI "\fISparse matrix iteration callback.\fP"
.ti -1c
.RI "typedef unsigned long(* \fBsmat_comp_t\fP )(\fBdb_key_t\fP *, \fBsmat_entry_t\fP *)"
.br
.RI "\fISparse matrix comparison callback.\fP"
.ti -1c
.RI "typedef enum \fB_smat_loc_e\fP \fBsmat_loc_t\fP"
.br
.RI "\fISparse matrix location.\fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_smat_loc_e\fP { \fBSMAT_LOC_FIRST\fP, \fBSMAT_LOC_SECOND\fP }"
.br
.RI "\fISparse matrix location.\fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "unsigned long \fBsmat_cleanup\fP (void)"
.br
.RI "\fIClean up the smat free list.\fP"
.ti -1c
.RI "unsigned long \fBsmat_freemem\fP (void)"
.br
.RI "\fIReport how much memory is used by the free list.\fP"
.ti -1c
.RI "unsigned long \fBst_init\fP (\fBsmat_table_t\fP *table, unsigned long flags, \fBsmat_resize_t\fP resize, void *extra, unsigned long init_mod)"
.br
.ti -1c
.RI "unsigned long \fBst_add\fP (\fBsmat_table_t\fP *table, \fBsmat_entry_t\fP **entry_p, \fBsmat_head_t\fP *head1, \fBlink_loc_t\fP loc1, \fBsmat_entry_t\fP *ent1, \fBsmat_head_t\fP *head2, \fBlink_loc_t\fP loc2, \fBsmat_entry_t\fP *ent2)"
.br
.RI "\fIAdd an entry to a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBst_remove\fP (\fBsmat_table_t\fP *table, \fBsmat_entry_t\fP *entry)"
.br
.RI "\fIRemove an entry from a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBst_find\fP (\fBsmat_table_t\fP *table, \fBsmat_entry_t\fP **entry_p, \fBsmat_head_t\fP *head1, \fBsmat_head_t\fP *head2)"
.br
.RI "\fIFind an entry in a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBst_iter\fP (\fBsmat_table_t\fP *table, \fBsmat_iter_t\fP iter_func, void *extra)"
.br
.RI "\fIIterate over each entry in a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBst_flush\fP (\fBsmat_table_t\fP *table, \fBsmat_iter_t\fP flush_func, void *extra)"
.br
.RI "\fIFlush a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBst_resize\fP (\fBsmat_table_t\fP *table, unsigned long new_size)"
.br
.RI "\fIResize a sparse matrix table.\fP"
.ti -1c
.RI "unsigned long \fBst_free\fP (\fBsmat_table_t\fP *table)"
.br
.RI "\fIFree memory used by an empty sparse matrix table.\fP"
.ti -1c
.RI "unsigned long \fBsh_init\fP (\fBsmat_head_t\fP *head, \fBsmat_loc_t\fP elem, void *object)"
.br
.RI "\fIDynamically initialize a sparse matrix row or column head.\fP"
.ti -1c
.RI "unsigned long \fBsh_move\fP (\fBsmat_head_t\fP *head, \fBsmat_entry_t\fP *elem, \fBlink_loc_t\fP loc, \fBsmat_entry_t\fP *elem2)"
.br
.RI "\fIMove an entry within a row or column list.\fP"
.ti -1c
.RI "unsigned long \fBsh_find\fP (\fBsmat_head_t\fP *head, \fBsmat_entry_t\fP **elem_p, \fBsmat_comp_t\fP comp_func, \fBsmat_entry_t\fP *start, \fBdb_key_t\fP *key)"
.br
.RI "\fIFind an entry in a row or column of a sparse matrix.\fP"
.ti -1c
.RI "unsigned long \fBsh_iter\fP (\fBsmat_head_t\fP *head, \fBsmat_entry_t\fP *start, \fBsmat_iter_t\fP iter_func, void *extra, unsigned long flags)"
.br
.RI "\fIIterate over each entry in a row or column of a sparse matrix.\fP"
.in -1c
.SH "DEFINE DOCUMENTATION"
.PP 
.SS "#define se_flags(entry)"
.PP
This macro retrieves a set of user-defined flags associated with the entry. It may be used as an lvalue to set those flags.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to a \fBsmat_entry_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing the flags associated with the entry. 
.SS "#define se_hash(entry)"
.PP
This macro retrieves the hash value of the given sparse matrix entry. If the sparse matrix hash been resized, this value may not be the same as a previous value.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to a \fBsmat_entry_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing the hash code for the entry. 
.SS "#define se_lflags(entry, n)"
.PP
This macro retrieves a set of user-defined flags associated with the entry in a sparse matrix list. It may be used as an lvalue to set those flags.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to \fBsmat_entry_t\fP. 
.TP
\fB\fIn\fP\fP
One of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP to specify which list thread is desired.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing the flags associated with the entry. 
.SS "#define se_next(entry, n)"
.PP
This macro retrieves a pointer to the \fBlink_elem_t\fP for the next element in the sparse matrix list.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCentry\fP and \fCn\fP arguments twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to \fBsmat_entry_t\fP. 
.TP
\fB\fIn\fP\fP
One of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP to specify which list thread is desired.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fBsmat_entry_t\fP. 
.SS "#define se_object(entry, n)"
.PP
This macro retrieves a pointer to one of the object represented by the entry. It may be used as an lvalue to change the object pointed to. Care should be taken when using this feature.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to \fBsmat_entry_t\fP. 
.TP
\fB\fIn\fP\fP
One of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP to specify which list thread is desired.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fCvoid\fP representing the object. 
.SS "#define se_prev(entry, n)"
.PP
This macro retrieves a pointer to the \fBlink_elem_t\fP for the previous element in the sparse matrix list.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCentry\fP and \fCn\fP arguments twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to \fBsmat_entry_t\fP. 
.TP
\fB\fIn\fP\fP
One of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP to specify which list thread is desired.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fBsmat_entry_t\fP. 
.SS "#define se_table(entry)"
.PP
This macro retrieves a pointer to the table that the sparse matrix entry is in.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to a \fBsmat_entry_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBsmat_table_t\fP. 
.SS "#define se_verify(entry)"
.PP
This macro verifies that a given pointer actually does point to a sparse matrix entry.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCentry\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIentry\fP\fP
A pointer to a \fBsmat_entry_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCentry\fP is a valid sparse matrix entry or false otherwise. 
.SS "#define sh_count(head)"
.PP
This macro retrieves the number of elements in the sparse matrix list rooted at \fChead\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing a count of the number of elements in the sparse matrix list. 
.SS "#define sh_elem(head)"
.PP
This macro retrieves the position indicator for the sparse matrix head. It will return one of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fBsmat_loc_t\fP. 
.SS "#define sh_first(head)"
.PP
This macro retrieves a pointer to the \fBsmat_entry_t\fP for the first element in the sparse matrix list.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fChead\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fBsmat_entry_t\fP. 
.SS "#define sh_frozen(head)"
.PP
This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. 
.SS "#define sh_last(head)"
.PP
This macro retrieves a pointer to the \fBsmat_entry_t\fP for the last element in the sparse matrix list.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fChead\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fBsmat_entry_t\fP. 
.SS "#define sh_object(head)"
.PP
This macro retrieves a pointer to the object referenced by the sparse matrix list head.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fCvoid\fP. 
.SS "#define sh_size(head)"
.PP
This macro returns the physical size of the memory allocated by the library for this sparse matrix list.
.PP
\fBNote: \fP
.in +1c
The \fBst_size()\fP macro already counts the memory for each list in the table. Summing the results of \fBsh_size()\fP and \fBst_size()\fP will over-count the amount of memory actually in use.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A \fCsize_t\fP. 
.SS "#define sh_table(head)"
.PP
If there are any elements in this sparse matrix list head, this macro will retrieve a pointer to the table in which they reside.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fBsmat_table_t\fP. 
.SS "#define sh_verify(head)"
.PP
This macro verifies that a given pointer actually does point to a sparse matrix head.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fChead\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fChead\fP is a valid sparse matrix head or false otherwise. 
.SS "#define SMAT_HEAD_INIT(elem, object)"
.PP
This macro statically initializes a \fBsmat_head_t\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIelem\fP\fP
One of \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP specifing whether the object is a member of the set of rows or columns. 
.TP
\fB\fIobject\fP\fP
A pointer to \fCvoid\fP representing the object associated with the list head. 
.SS "#define SMAT_TABLE_INIT(flags, resize, extra)"
.PP
This macro statically initializes a \fBsmat_table_t\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIflags\fP\fP
A bit-wise OR of \fBHASH_FLAG_AUTOGROW\fP and \fBHASH_FLAG_AUTOSHRINK\fP. If neither behavior is desired, use 0. 
.TP
\fB\fIresize\fP\fP
A \fBsmat_resize_t\fP function pointer for determining whether resizing is permitted and/or for notification of the resize. 
.TP
\fB\fIextra\fP\fP
Extra pointer data that should be associated with the sparse matrix. 
.SS "#define st_count(table)"
.PP
This macro retrieves the total number of items actually in the sparse matrix table.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing a count of the number of items in the sparse matrix table. 
.SS "#define st_extra(table)"
.PP
This macro retrieves the extra pointer data associated with a particular sparse matrix table.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fCvoid\fP. 
.SS "#define st_flags(table)"
.PP
This macro retrieves the flags associated with the sparse matrix table. Only \fBHASH_FLAG_AUTOGROW\fP and \fBHASH_FLAG_AUTOSHRINK\fP have any meaning to the application; all other bits are reserved for use in the library. This macro may be used as an lvalue, but care must be taken to avoid modifying the library-specific bits.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing the flags for the sparse matrix table. 
.SS "#define st_frozen(table)"
.PP
This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. 
.SS "#define st_modulus(table)"
.PP
This macro retrieves the number of buckets allocated for the sparse matrix table. An application may wish to save this value between invocations to avoid the overhead of growing the table while filling it with data.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing the number of buckets allocated for the sparse matrix table. 
.SS "#define st_size(table)"
.PP
This macro returns the physical size of the memory allocated by the library for this sparse matrix table.
.PP
\fBNote: \fP
.in +1c
The \fBst_size()\fP macro already counts the memory for each list in the table. Summing the results of \fBsh_size()\fP and \fBst_size()\fP will over-count the amount of memory actually in use.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
A \fCsize_t\fP. 
.SS "#define st_verify(table)"
.PP
This macro verifies that a given pointer actually does point to a sparse matrix table.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCtable\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCtable\fP is a valid sparse matrix table or false otherwise. 
.SH "TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef unsigned long(* smat_comp_t)(\fBdb_key_t\fP *, \fBsmat_entry_t\fP *)"
.PP
This function pointer references a callback used by \fBsh_find()\fP. It should return 0 if the sparse matrix entry represented by the second argument matches the key passed as the first argument. 
.SS "typedef struct _smat_entry_s smat_entry_t"
.PP
This structure is allocated by the library and represents a single element in a sparse matrix. 
.SS "typedef struct _smat_head_s smat_head_t"
.PP
This structure is the head of a linked list of sparse matrix entries. 
.SS "typedef unsigned long(* smat_iter_t)(\fBsmat_table_t\fP *, \fBsmat_entry_t\fP *, void *)"
.PP
This function pointer references a callback used by \fBst_iter()\fP, \fBst_flush()\fP, \fBsh_iter()\fP, and sh_flush(). It should return 0 for success. A non-zero return value will terminate the operation and will become the return value of the call. 
.SS "typedef enum \fB_smat_loc_e\fP smat_loc_t"
.PP
See the documentation for the enumeration \fB_smat_loc_e\fP. 
.SS "typedef unsigned long(* smat_resize_t)(\fBsmat_table_t\fP *, unsigned long)"
.PP
This function pointer references a callback that will be called with both the old and new sparse matrix table sizes whenever a sparse matrix's hash table table is resized. It should return non-zero only when the resize should be inhibited. 
.SS "typedef struct _smat_table_s smat_table_t"
.PP
This structure is the basis of all sparse matrices maintained by this library. 
.SH "ENUMERATION TYPE DOCUMENTATION"
.PP 
.SS "enum _smat_loc_e"
.PP
This enumeration is used to specify whether an element is a row or column element. It should be referenced by the typedef \fBsmat_loc_t\fP. 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fISMAT_LOC_FIRST\fP \fP\fP
First entry (``row''). 
.TP
\fB\fI\fISMAT_LOC_SECOND\fP \fP\fP
Second entry (``column''). 
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "unsigned long sh_find (\fBsmat_head_t\fP * head, \fBsmat_entry_t\fP ** elem_p, \fBsmat_comp_t\fP comp_func, \fBsmat_entry_t\fP * start, \fBdb_key_t\fP * key)"
.PP
This function iterates through the given row or column of a sparse matrix looking for an element that matches the given \fCkey\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP. 
.TP
\fB\fIelem_p\fP\fP
A pointer to a pointer to a \fBsmat_entry_t\fP. This is a result pramater. \fCNULL\fP is an invalid value. 
.TP
\fB\fIcomp_func\fP\fP
A pointer to a comparison function used to compare the key to a particular entry. See the documentation for \fBsmat_comp_t\fP for more information. 
.TP
\fB\fIstart\fP\fP
A pointer to a \fBsmat_entry_t\fP describing where in the row or column to start. If \fCNULL\fP is passed, the beginning of the row or column will be assumed. 
.TP
\fB\fIkey\fP\fP
A key to search for.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
\fCstart\fP is not in this row or column. 
.TP
\fB\fIDB_ERR_NOENTRY\fP\fP
No matching entry was found. 
.SS "unsigned long sh_init (\fBsmat_head_t\fP * head, \fBsmat_loc_t\fP elem, void * object)"
.PP
This function dynamically initializes a sparse matrix row or column linked list head. The \fCelem\fP argument specifies whether the object is to be associated with a \fBSMAT_LOC_FIRST\fP list or a \fBSMAT_LOC_SECOND\fP list.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP to be initialized. 
.TP
\fB\fIelem\fP\fP
Either \fBSMAT_LOC_FIRST\fP or \fBSMAT_LOC_SECOND\fP. 
.TP
\fB\fIobject\fP\fP
A pointer to the object containing the sparse matrix row or column head.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.SS "unsigned long sh_iter (\fBsmat_head_t\fP * head, \fBsmat_entry_t\fP * start, \fBsmat_iter_t\fP iter_func, void * extra, unsigned long flags)"
.PP
This function iterates over a row or column of a sparse matrix, executing the given \fCiter_func\fP for each entry.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP. 
.TP
\fB\fIstart\fP\fP
A pointer to a \fBsmat_entry_t\fP describing where in the row or column to start. If \fCNULL\fP is passed, the beginning of the row or column will be assumed. 
.TP
\fB\fIiter_func\fP\fP
A pointer to a callback function used to perform user-specified actions on an entry in a row or column of a sparse matrix. \fCNULL\fP is an invalid value. See the documentation for \fBsmat_iter_t\fP for more information. 
.TP
\fB\fIextra\fP\fP
A \fCvoid\fP pointer that will be passed to \fCiter_func\fP. 
.TP
\fB\fIflags\fP\fP
If \fBDB_FLAG_REVERSE\fP is given, iteration will be done from the end of the list backwards towards the head.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
\fCstart\fP is not in this row or column. 
.SS "unsigned long sh_move (\fBsmat_head_t\fP * head, \fBsmat_entry_t\fP * elem, \fBlink_loc_t\fP loc, \fBsmat_entry_t\fP * elem2)"
.PP
This function allows the specified entry to be shifted within the linked list describing the row or column. It is very similar to the \fBll_move()\fP function.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIhead\fP\fP
A pointer to a \fBsmat_head_t\fP. 
.TP
\fB\fIelem\fP\fP
A pointer to the \fBsmat_entry_t\fP describing the entry to be moved. 
.TP
\fB\fIloc\fP\fP
A \fBlink_loc_t\fP indicating where the entry should be moved to. 
.TP
\fB\fIelem2\fP\fP
A pointer to a \fBsmat_entry_t\fP describing another entry in the list if \fCloc\fP is \fBLINK_LOC_BEFORE\fP or \fBLINK_LOC_AFTER\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_BUSY\fP\fP
\fCelem\fP and \fCelem2\fP are the same entry. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
\fCelem\fP or \fCelem2\fP are in a different row or column. 
.TP
\fB\fIDB_ERR_UNUSED\fP\fP
\fCelem\fP or \fCelem2\fP are not in any row or column. 
.SS "unsigned long smat_cleanup (void)"
.PP
This function frees all smat_entry_t objects on the internal free list. It is always successful and returns 0. 
.SS "unsigned long smat_freemem (void)"
.PP
This function returns the amount of memory being used by the internal free list of smat_entry_t objects.
.PP
\fBReturns: \fP
.in +1c
A number indicating the size, in bytes, of the memory allocated for smat_entry_t objects on the free list. 
.SS "unsigned long st_add (\fBsmat_table_t\fP * table, \fBsmat_entry_t\fP ** entry_p, \fBsmat_head_t\fP * head1, \fBlink_loc_t\fP loc1, \fBsmat_entry_t\fP * ent1, \fBsmat_head_t\fP * head2, \fBlink_loc_t\fP loc2, \fBsmat_entry_t\fP * ent2)"
.PP
This function adds an entry to a sparse matrix. The entry is referenced in three different places, thus the complex set of arguments. This function will allocate a \fBsmat_entry_t\fP and return it through the \fCentry_p\fP result parameter.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fIentry_p\fP\fP
A pointer to a pointer to a \fBsmat_entry_t\fP. This is a result parameter. If \fCNULL\fP is passed, the addition will be performed and an appropriate error code returned. 
.TP
\fB\fIhead1\fP\fP
A pointer to a \fBsmat_head_t\fP representing a \fBSMAT_LOC_FIRST\fP sparse matrix list. 
.TP
\fB\fIloc1\fP\fP
A \fBlink_loc_t\fP indicating where the entry should be added for \fChead1\fP. 
.TP
\fB\fIent1\fP\fP
A pointer to a \fBsmat_entry_t\fP describing another element in the list represented by \fChead1\fP if \fCloc1\fP is \fBLINK_LOC_BEFORE\fP or \fBLINK_LOC_AFTER\fP. 
.TP
\fB\fIhead2\fP\fP
A pointer to a \fBsmat_head_t\fP representing a \fBSMAT_LOC_SECOND\fP sparse matrix list. 
.TP
\fB\fIloc2\fP\fP
A \fBlink_loc_t\fP indicating where the entry should be added for \fChead2\fP. 
.TP
\fB\fIent2\fP\fP
A pointer to a \fBsmat_entry_t\fP describing another element in the list represented by \fChead2\fP if \fCloc2\fP is \fBLINK_LOC_BEFORE\fP or \fBLINK_LOC_AFTER\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_BUSY\fP\fP
One of the arguments is already in the table. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The table is currently frozen. 
.TP
\fB\fIDB_ERR_NOTABLE\fP\fP
The bucket table has not been allocated and automatic growth is not enabled. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
One of the arguments was not in the proper table or list. 
.TP
\fB\fIDB_ERR_UNUSED\fP\fP
One of the \fCent\fP arguments is not presently in a list. 
.TP
\fB\fIDB_ERR_UNRECOVERABLE\fP\fP
An unrecoverable error occurred while resizing the table. 
.TP
\fB\fIENOMEM\fP\fP
No memory could be allocated for the \fBsmat_entry_t\fP structure. 
.SS "unsigned long st_find (\fBsmat_table_t\fP * table, \fBsmat_entry_t\fP ** entry_p, \fBsmat_head_t\fP * head1, \fBsmat_head_t\fP * head2)"
.PP
This function looks up the entry matching the given \fChead1\fP and \fChead2\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fIentry_p\fP\fP
A pointer to a pointer to a \fBsmat_entry_t\fP. This is a result parameter. If \fCNULL\fP is passed, the lookup will be performed and an appropriate error code returned. 
.TP
\fB\fIhead1\fP\fP
A pointer to a \fBsmat_head_t\fP initialized to \fBSMAT_LOC_FIRST\fP. 
.TP
\fB\fIhead2\fP\fP
A pointer to a \fBsmat_head_t\fP initialized to \fBSMAT_LOC_SECOND\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
One or both of \fChead1\fP or \fChead2\fP are not referenced in this table. 
.TP
\fB\fIDB_ERR_NOENTRY\fP\fP
No matching entry was found. 
.SS "unsigned long st_flush (\fBsmat_table_t\fP * table, \fBsmat_iter_t\fP flush_func, void * extra)"
.PP
This function flushes a sparse matrix--that is, it removes each entry from the matrix. If a \fCflush_func\fP is specified, it will be called on the entry after it has been removed from the table, and may safely call \fCfree()\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fIflush_func\fP\fP
A pointer to a callback function used to perform user-specified actions on an entry after removing it from the table. May be \fCNULL\fP. See the documentation for \fBsmat_iter_t\fP for more information. 
.TP
\fB\fIextra\fP\fP
A \fCvoid\fP pointer that will be passed to \fCiter_func\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The sparse matrix is frozen. 
.SS "unsigned long st_free (\fBsmat_table_t\fP * table)"
.PP
This function releases the memory used by the bucket table of the empty hash table associated with a sparse matrix.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The table is frozen. 
.TP
\fB\fIDB_ERR_NOTEMPTY\fP\fP
The table is not empty. 
.SS "unsigned long st_init (\fBsmat_table_t\fP * table, unsigned long flags, \fBsmat_resize_t\fP resize, void * extra, unsigned long init_mod)"
.PP
This function dynamically initializes a sparse matrix table.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP to be initialized. 
.TP
\fB\fIflags\fP\fP
A bit-wise OR of \fBHASH_FLAG_AUTOGROW\fP and \fBHASH_FLAG_AUTOSHRINK\fP. If neither behavior is desired, use 0. 
.TP
\fB\fIresize\fP\fP
A \fBhash_resize_t\fP function pointer for determining whether resizing is permitted and/or for notification of the resize. 
.TP
\fB\fIextra\fP\fP
Extra pointer data that should be associated with the sparse matrix table. 
.TP
\fB\fIinit_mod\fP\fP
An initial modulus for the table. This will presumably be extracted by \fBst_modulus()\fP in a previous invocation of the application. A 0 value is valid.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIENOMEM\fP\fP
Unable to allocate memory. 
.SS "unsigned long st_iter (\fBsmat_table_t\fP * table, \fBsmat_iter_t\fP iter_func, void * extra)"
.PP
This function iterates over every entry in a sparse matrix (in an unspecified order), executing the given \fCiter_func\fP on each entry.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fIiter_func\fP\fP
A pointer to a callback function used to perform user-specified actions on an entry in a sparse matrix. \fCNULL\fP is an invalid value. See the documentation for \fBsmat_iter_t\fP for more information. 
.TP
\fB\fIextra\fP\fP
A \fCvoid\fP pointer that will be passed to \fCiter_func\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The sparse matrix is frozen. 
.SS "unsigned long st_remove (\fBsmat_table_t\fP * table, \fBsmat_entry_t\fP * entry)"
.PP
This function removes the given entry from the specified sparse matrix.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fIentry\fP\fP
A pointer to a \fBsmat_entry_t\fP to be removed from the table.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
Entry is not in this sparse matrix. 
.TP
\fB\fIDB_ERR_UNRECOVERABLE\fP\fP
An unrecoverable error occurred while removing the entry from the table. 
.SS "unsigned long st_resize (\fBsmat_table_t\fP * table, unsigned long new_size)"
.PP
This function resizes the hash table associated with a sparse matrix based on the \fCnew_size\fP parameter. See the documentation for \fBht_resize()\fP for more information.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItable\fP\fP
A pointer to a \fBsmat_table_t\fP. 
.TP
\fB\fInew_size\fP\fP
A new size value for the table.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The table is currently frozen. 
.TP
\fB\fIDB_ERR_UNRECOVERABLE\fP\fP
A catastrophic error was encountered. The table is now unusable. 
.TP
\fB\fIENOMEM\fP\fP
No memory could be allocated for the new bucket table. 
