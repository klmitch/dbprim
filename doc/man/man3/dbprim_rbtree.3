.TH "Red-black trees" 3 "23 Aug 2003" "Database Primitives Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Red-black trees \- 
.SH "DETAILED DESCRIPTION"
.PP 
Red-black trees are a form of binary search tree. One essential feature of binary search trees is that they need to be balanced in order to be efficient. Many algorithms exist for keeping trees balanced, but among the easiest to implement is the red-black tree. In a red-black tree, every node is given a color--either red or black--and there are various rules for what color nodes can be present where in the tree. This library implements these rules, along with functions for traversing the tree in any desired tree order.
.PP
A red-black tree is represented by a caller-allocated \fBrb_tree_t\fP structure. This structure describes various characteristics of the tree, such as the number of nodes in the tree, and includes a pointer to the root node of the tree. Nodes may be added to the tree using \fBrt_add()\fP or removed from the tree using \fBrt_remove()\fP. Additionally, the key on a given node may be changed using the \fBrt_move()\fP function. Nodes may be looked up with \fBrt_find()\fP, and \fBrt_iter()\fP will execute a user-defined function for each node in the tree in the specified order. To remove all entries in the tree, simply call the \fBrt_flush()\fP function. If you must manually iterate through the tree, you may call the \fBrt_next()\fP and \fBrt_prev()\fP functions to determine the next or previous nodes to visit.
.PP
There are three ways to traverse a binary tree. The first, known as 'preorder,' visits the root node, then traverses the left subtree in preorder, then traverses the right subtree in preorder. The second, known an 'inorder,' traverses the left subtree in inorder, then the root node, then the right subtree in inorder. (This particular ordering retrieves the nodes in lexical order; thus its name.) The third ordering is known as 'postorder'; this ordering traverses the left subtree, the right subtree, then visits the root node. To iterate over the tree in one of these orderings, simply call \fBrt_iter()\fP (or \fBrt_next()\fP or \fBrt_prev()\fP) with the \fBRBT_ORDER_PRE\fP, \fBRBT_ORDER_IN\fP, or \fBRBT_ORDER_POST\fP flags. You may OR these flags with \fBDB_FLAG_REVERSE\fP to reverse the traversal ordering, if you wish. 
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBRB_TREE_INIT\fP(comp, extra)"
.br
.RI "\fIRed-black tree static initializer.\fP"
.ti -1c
.RI "#define \fBrt_verify\fP(tree)"
.br
.RI "\fIRed-black tree verification macro.\fP"
.ti -1c
.RI "#define \fBrt_frozen\fP(tree)"
.br
.RI "\fIDetermine if a red-black tree is frozen.\fP"
.ti -1c
.RI "#define \fBrt_count\fP(tree)"
.br
.RI "\fIRed-black tree count.\fP"
.ti -1c
.RI "#define \fBrt_root\fP(tree)"
.br
.RI "\fIRed-black tree root node.\fP"
.ti -1c
.RI "#define \fBrt_comp\fP(tree)"
.br
.RI "\fIRed-black tree comparison function.\fP"
.ti -1c
.RI "#define \fBrt_extra\fP(tree)"
.br
.RI "\fIExtra pointer data in a red-black tree.\fP"
.ti -1c
.RI "#define \fBRBT_ORDER_PRE\fP"
.br
.RI "\fIPreorder tree traversal method.\fP"
.ti -1c
.RI "#define \fBRBT_ORDER_IN\fP"
.br
.RI "\fIInorder tree traversal method.\fP"
.ti -1c
.RI "#define \fBRBT_ORDER_POST\fP"
.br
.RI "\fIPostorder tree traversal method.\fP"
.ti -1c
.RI "#define \fBrt_prev\fP(tree, node_io, flags)"
.br
.RI "\fIGet the previous node.\fP"
.ti -1c
.RI "#define \fBRB_NODE_INIT\fP(value)"
.br
.RI "\fIRed-black tree node static initializer.\fP"
.ti -1c
.RI "#define \fBrn_verify\fP(node)"
.br
.RI "\fIRed-black tree node verification macro.\fP"
.ti -1c
.RI "#define \fBrn_color\fP(node)"
.br
.RI "\fIRed-black tree node color.\fP"
.ti -1c
.RI "#define \fBrn_tree\fP(node)"
.br
.RI "\fIRed-black tree node's tree pointer.\fP"
.ti -1c
.RI "#define \fBrn_parent\fP(node)"
.br
.RI "\fIRed-black tree node's parent pointer.\fP"
.ti -1c
.RI "#define \fBrn_left\fP(node)"
.br
.RI "\fIRed-black tree node's left pointer.\fP"
.ti -1c
.RI "#define \fBrn_right\fP(node)"
.br
.RI "\fIRed-black tree node's right pointer.\fP"
.ti -1c
.RI "#define \fBrn_key\fP(node)"
.br
.RI "\fIRed-black tree node's key pointer.\fP"
.ti -1c
.RI "#define \fBrn_value\fP(node)"
.br
.RI "\fIRed-black tree node's value pointer.\fP"
.ti -1c
.RI "#define \fBrn_isblack\fP(node)"
.br
.RI "\fITest if a given node is black.\fP"
.ti -1c
.RI "#define \fBrn_isred\fP(node)"
.br
.RI "\fITest if a given node is red.\fP"
.ti -1c
.RI "#define \fBrn_isleft\fP(node)"
.br
.RI "\fITest if a given node is the left node of its parent.\fP"
.ti -1c
.RI "#define \fBrn_isright\fP(node)"
.br
.RI "\fITest if a given node is the right node of its parent.\fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef _rb_tree_s \fBrb_tree_t\fP"
.br
.RI "\fIRed-black tree.\fP"
.ti -1c
.RI "typedef _rb_node_s \fBrb_node_t\fP"
.br
.RI "\fIRed-black tree node.\fP"
.ti -1c
.RI "typedef unsigned long(* \fBrb_iter_t\fP )(\fBrb_tree_t\fP *, \fBrb_node_t\fP *, void *)"
.br
.RI "\fIRed-black tree iteration callback.\fP"
.ti -1c
.RI "typedef long(* \fBrb_comp_t\fP )(\fBrb_tree_t\fP *, \fBdb_key_t\fP *, \fBdb_key_t\fP *)"
.br
.RI "\fIRed-black tree comparison callback.\fP"
.ti -1c
.RI "typedef enum \fB_rb_color_e\fP \fBrb_color_t\fP"
.br
.RI "\fIRed-black tree node color.\fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_rb_color_e\fP { \fBRB_COLOR_NONE\fP, \fBRB_COLOR_RED\fP, \fBRB_COLOR_BLACK\fP }"
.br
.RI "\fIRed-black tree node color.\fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "unsigned long \fBrt_init\fP (\fBrb_tree_t\fP *tree, \fBrb_comp_t\fP comp, void *extra)"
.br
.RI "\fIDynamically initialize a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrt_add\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP *node, \fBdb_key_t\fP *key)"
.br
.RI "\fIAdd a node to a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrt_move\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP *node, \fBdb_key_t\fP *key)"
.br
.RI "\fIMove a node in a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrt_remove\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP *node)"
.br
.RI "\fIRemove a node from a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrt_find\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP **node_p, \fBdb_key_t\fP *key)"
.br
.RI "\fIFind an entry in a red-black table.\fP"
.ti -1c
.RI "unsigned long \fBrt_next\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP **node_io, unsigned long flags)"
.br
.RI "\fIGet the next node.\fP"
.ti -1c
.RI "unsigned long \fBrt_iter\fP (\fBrb_tree_t\fP *tree, \fBrb_node_t\fP *start, \fBrb_iter_t\fP iter_func, void *extra, unsigned long flags)"
.br
.RI "\fIIterate over each entry in a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrt_flush\fP (\fBrb_tree_t\fP *tree, \fBrb_iter_t\fP flush_func, void *extra)"
.br
.RI "\fIFlush a red-black tree.\fP"
.ti -1c
.RI "unsigned long \fBrn_init\fP (\fBrb_node_t\fP *node, void *value)"
.br
.RI "\fIDynamically initialize a red-black tree node.\fP"
.in -1c
.SH "DEFINE DOCUMENTATION"
.PP 
.SS "#define RB_NODE_INIT(value)"
.PP
This macro statically initializes a \fBrb_node_t\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIvalue\fP\fP
A pointer to \fCvoid\fP representing the object associated with the node. 
.SS "#define RB_TREE_INIT(comp, extra)"
.PP
This macro statically initializes a \fBrb_tree_t\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIcomp\fP\fP
A \fBrb_comp_t\fP function pointer for a comparison function. 
.TP
\fB\fIextra\fP\fP
Extra pointer data that should be associated with the red-black tree. 
.SS "#define RBT_ORDER_IN"
.PP
If this flag is passed to \fBrt_iter()\fP, an inorder iteration will be performed. 
.SS "#define RBT_ORDER_POST"
.PP
If this flag is passed to \fBrt_iter()\fP, a postorder iteration will be performed. 
.SS "#define RBT_ORDER_PRE"
.PP
If this flag is passed to \fBrt_iter()\fP, a preorder iteration will be performed. 
.SS "#define rn_color(node)"
.PP
This macro retrieves the color of the \fCnode\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A \fBrb_color_t\fP value expressing the color of the \fCnode\fP. 
.SS "#define rn_isblack(node)"
.PP
This macro safely tests whether a given red-black tree node is black.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCnode\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCnode\fP is black or false otherwise. 
.SS "#define rn_isleft(node)"
.PP
This macro safely tests whether a given red-black tree node is the left node of its parent.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCnode\fP argument three times.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCnode\fP is the left node of its parent or false otherwise. 
.SS "#define rn_isred(node)"
.PP
This macro safely tests whether a given red-black tree node is red.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCnode\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCnode\fP is red or false otherwise. 
.SS "#define rn_isright(node)"
.PP
This macro safely tests whether a given red-black tree node is the right node of its parent.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCnode\fP argument three times.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCnode\fP is the right node of its parent or false otherwise. 
.SS "#define rn_key(node)"
.PP
This macro retrieves the key associated with the red-black tree node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBdb_key_t\fP. 
.SS "#define rn_left(node)"
.PP
This macro retrieves a pointer to the node's left node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBrb_node_t\fP representing the left node of the given \fCnode\fP. 
.SS "#define rn_parent(node)"
.PP
This macro retrieves a pointer to the node's parent node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBrb_node_t\fP representing the parent of the given \fCnode\fP. 
.SS "#define rn_right(node)"
.PP
This macro retrieves a pointer to the node's right node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBrb_node_t\fP representing the right node of the given \fCnode\fP. 
.SS "#define rn_tree(node)"
.PP
This macro retrieves a pointer to the red-black tree the node is in.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBrb_tree_t\fP. 
.SS "#define rn_value(node)"
.PP
This macro retrieves the value associated with the red-black tree's node. It may be treated as an lvalue to change that value. Care should be taken when using this option.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fCvoid\fP representing the value associated with this node. 
.SS "#define rn_verify(node)"
.PP
This macro verifies that a given pointer actually does point to a red-black tree node.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCnode\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCentry\fP is a valid red-black tree node or false otherwise. 
.SS "#define rt_comp(tree)"
.PP
This macro retrieves the comparison function pointer.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
A \fBrb_comp_t\fP. 
.SS "#define rt_count(tree)"
.PP
This macro retrieves the total number of items actually in the red-black tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
An \fCunsigned long\fP containing a count of the number of items in the red-black tree. 
.SS "#define rt_extra(tree)"
.PP
This macro retrieves the extra pointer data associated with a particular red-black tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to \fCvoid\fP. 
.SS "#define rt_frozen(tree)"
.PP
This macro returns a non-zero value if the tree is currently frozen. The red-black tree may be frozen if there is an iteration in progress.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
A zero value if the table is not frozen or a non-zero value if the table is frozen. 
.SS "#define rt_prev(tree, node_io, flags)"
.PP
Obtains the previous node in the given iteration scheme. See \fBrt_next()\fP for more information. 
.SS "#define rt_root(tree)"
.PP
This macro retrieves the root node of the tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
A pointer to a \fBrb_node_t\fP. 
.SS "#define rt_verify(tree)"
.PP
This macro verifies that a given pointer actually does point to a red-black tree.
.PP
\fBWarning: \fP
.in +1c
This macro may evaluate the \fCtree\fP argument twice.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP.
.PP
\fBReturns: \fP
.in +1c
Boolean true if \fCtree\fP is a valid red-black tree or false otherwise. 
.SH "TYPEDEF DOCUMENTATION"
.PP 
.SS "typedef enum \fB_rb_color_e\fP rb_color_t"
.PP
See the documentation for the enumeration \fB_rb_color_e\fP. 
.SS "typedef long(* rb_comp_t)(\fBrb_tree_t\fP *, \fBdb_key_t\fP *, \fBdb_key_t\fP *)"
.PP
This function pointer references a callback used to compare nodes in a red-black tree. It should return 0 for identical entries, less than 0 if the first key is less than the second, or greater than 0 if the first key is greater than the second. 
.SS "typedef unsigned long(* rb_iter_t)(\fBrb_tree_t\fP *, \fBrb_node_t\fP *, void *)"
.PP
This function pointer references a callback used by rb_iter() and rb_flush(). It should return 0 for success. A non-zero return value will terminate the operation and will become the return value of the call. 
.SS "typedef struct _rb_node_s rb_node_t"
.PP
This structure represents a single node in a red-black tree. 
.SS "typedef struct _rb_tree_s rb_tree_t"
.PP
This structure is the basis of all red-black trees maintained by this library. 
.SH "ENUMERATION TYPE DOCUMENTATION"
.PP 
.SS "enum _rb_color_e"
.PP
This enumeration is used to specify the color of a node of a red-black tree. 
.PP
\fBEnumeration values: \fP
.in +1c
.TP
\fB\fI\fIRB_COLOR_NONE\fP \fP\fP
Node is uncolored as of yet. 
.TP
\fB\fI\fIRB_COLOR_RED\fP \fP\fP
Node is red. 
.TP
\fB\fI\fIRB_COLOR_BLACK\fP \fP\fP
Node is black. 
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "unsigned long rn_init (\fBrb_node_t\fP * node, void * value)"
.PP
This function dynamically initializes a red-black tree node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_tree_t\fP to be initialized. 
.TP
\fB\fIvalue\fP\fP
A pointer to \fCvoid\fP which will be the value of the red-black tree entry.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
A \fCNULL\fP pointer was passed for \fCnode\fP. 
.SS "unsigned long rt_add (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP * node, \fBdb_key_t\fP * key)"
.PP
This function adds a node to a red-black tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP to be added to the tree. 
.TP
\fB\fIkey\fP\fP
A pointer to a \fBdb_key_t\fP containing the key for the node.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIDB_ERR_BUSY\fP\fP
The node is already in a tree. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The tree is currently frozen. 
.TP
\fB\fIDB_ERR_DUPLICATE\fP\fP
The entry is a duplicate of an existing node. 
.SS "unsigned long rt_find (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP ** node_p, \fBdb_key_t\fP * key)"
.PP
This function looks up an entry matching the given \fCkey\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fInode_p\fP\fP
A pointer to a pointer to a \fBrb_node_t\fP. This is a result parameter. If \fCNULL\fP is passed, the lookup will be performed and an appropriate error code returned. 
.TP
\fB\fIkey\fP\fP
A pointer to a \fBdb_key_t\fP describing the item to find.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_NOENTRY\fP\fP
No matching entry was found. 
.SS "unsigned long rt_flush (\fBrb_tree_t\fP * tree, \fBrb_iter_t\fP flush_func, void * extra)"
.PP
This function flushes a red-black tree--that is, it removes each node from the tree. If a \fCflush_func\fP is specified, it will be called on the node after it has been removed from the tree, and may safely call \fCfree()\fP.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fIflush_func\fP\fP
A pointer to a callback function used to perform user-specified actions on a node after removing it from the tree. May be \fCNULL\fP. See the documentation for \fBrb_iter_t\fP for more information. 
.TP
\fB\fIextra\fP\fP
A \fCvoid\fP pointer that will be passed to \fCflush_func\fP.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
The red-black tree is frozen. 
.SS "unsigned long rt_init (\fBrb_tree_t\fP * tree, \fBrb_comp_t\fP comp, void * extra)"
.PP
This function dynamically initializes a red-black tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP to be initialized. 
.TP
\fB\fIcomp\fP\fP
A \fBrb_comp_t\fP function pointer for a comparison function. 
.TP
\fB\fIextra\fP\fP
Extra pointer data that should be associated with the tree.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.SS "unsigned long rt_iter (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP * start, \fBrb_iter_t\fP iter_func, void * extra, unsigned long flags)"
.PP
This function iterates over every node in a red-black tree in the given traversal order, executing the given \fCiter_func\fP on each node.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fIstart\fP\fP
A pointer to a \fBrb_node_t\fP describing where in the tree to start. If \fCNULL\fP is passed, the first element of the tree for the specified order will be assumed. 
.TP
\fB\fIiter_func\fP\fP
A pointer to a callback function used to perform user-specified actions on a node in the red-black tree. \fCNULL\fP is an invalid value. See the documentation for \fBrb_iter_t\fP for more information. 
.TP
\fB\fIextra\fP\fP
A \fCvoid\fP pointer that will be passed to \fCiter_func\fP. 
.TP
\fB\fIflags\fP\fP
One of RBT_ORDER_PRE, RBT_ORDER_IN, or RBT_ORDER_POST, possibly ORed with DB_FLAG_REVERSE to reverse the order of iteration. Zero is not allowed.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
\fCstart\fP is not in this red-black tree. 
.SS "unsigned long rt_move (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP * node, \fBdb_key_t\fP * key)"
.PP
This function moves an existing node in the red-black tree to correspond to the new key.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP to be moved. It must already be in the red-black tree. 
.TP
\fB\fIkey\fP\fP
A pointer to a \fBdb_key_t\fP describing the new key for the node.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIDB_ERR_UNUSED\fP\fP
Node is not in a red-black tree. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
Node is not in this tree. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
Red-black tree is frozen. 
.TP
\fB\fIDB_ERR_DUPLICATE\fP\fP
New key is a duplicate of an existing key. 
.TP
\fB\fIDB_ERR_READDFAILED\fP\fP
Unable to re-add node to tree. 
.SS "unsigned long rt_next (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP ** node_io, unsigned long flags)"
.PP
This function obtains the next node in the given iteration scheme. The \fCnode_io\fP parameter is a value-result parameter--if the node pointer to which it points is \fCNULL\fP, the first node for the given iteration order will be loaded; otherwise, the next node in the given iteration order will be loaded.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fInode_io\fP\fP
A pointer to a pointer to a \fBrb_node_t\fP. If the pointer to which node_io points is \fCNULL\fP, the first node will be loaded, otherwise the next node will be loaded. 
.TP
\fB\fIflags\fP\fP
One of RBT_ORDER_PRE, RBT_ORDER_IN, or RBT_ORDER_POST, possibly ORed with DB_FLAG_REVERSE to reverse the order of iteration. Zero is not allowed.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An argument was invalid. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
\fCstart\fP is not in this red-black tree. 
.SS "unsigned long rt_remove (\fBrb_tree_t\fP * tree, \fBrb_node_t\fP * node)"
.PP
This function removes the given node from the specified red-black tree.
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fItree\fP\fP
A pointer to a \fBrb_tree_t\fP. 
.TP
\fB\fInode\fP\fP
A pointer to a \fBrb_node_t\fP to be removed from the tree.
.PP
\fBReturn values: \fP
.in +1c
.TP
\fB\fIDB_ERR_BADARGS\fP\fP
An invalid argument was given. 
.TP
\fB\fIDB_ERR_UNUSED\fP\fP
Node is not in a red-black tree. 
.TP
\fB\fIDB_ERR_WRONGTABLE\fP\fP
Node is not in this tree. 
.TP
\fB\fIDB_ERR_FROZEN\fP\fP
Red-black tree is frozen. 
