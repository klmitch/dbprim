<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Database Primitives Library: Sparse matrices</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a></div>
<h1>Sparse matrices</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Sparse matrices are advanced data structures used to represent associations. For instance, a manager may have several employees, but several of those employees may report to more than one manager. (Yes, this is a contrived example, so sue me.) The simplest way to represent such assocations is with a matrix, or a two-dimensional array. However, such an implementation cannot easily be extended dynamically--imagine if a manager retires and two more are hired, for instance. It would also use an enormous amount of memory, as most employees would only report to one or two managers.<p>
A sparse matrix solves this problem by only allocating memory for the cells in the full matrix which are actually used. That is, no memory is allocated to represent Alice reporting to Bob unless Alice actually does report to Bob. This is a simple concept, but fairly difficult to implement efficiently--how do you tell if Alice reports to Bob? The solution utilized by this library is to combine the strengths of linked lists and hash tables. Each cell is in two linked lists, rooted at the rows and columns of the matrix, but a hash table is used when attempting to look up a given cell. If the cell is allocated, then there will be an entry in the hash table, and finding the given cell is as fast as a hash table look-up.<p>
Because sparse matrices are so complicated, there are three structures and a variety of operations used. Two of the structures, <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> and <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>, are caller-allocated. However, the third structure, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>, must be allocated by the library. To avoid too much overhead from malloc(), a free list is used. The free list may be managed with the <a class="el" href="group__dbprim__smat.html#a7">smat_cleanup()</a> and <a class="el" href="group__dbprim__smat.html#a8">smat_freemem()</a> calls.<p>
The <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> contains the hash table. Only one of these need be allocated per type of association--for instance, in the above example, only one <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> needs to be allocated to represent the manager-employee relationship.<p>
The <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> contains the linked list. There are actually two kinds of these structures--one is <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a>, which could be regarded as a ``row,'' and the other is <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>, which could be regarded as a ``column.'' Which one is used for which type of data is irrelevant, as long as consistency is maintained. For the above example, a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> for a manager may be <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a>, and one for an employee must then be <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>. (These values are set when initializing the <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> structure.)<p>
An association may be created with the <a class="el" href="group__dbprim__smat.html#a10">st_add()</a> function, which allows an arbitrary ordering in the associated linked lists by the same mechanism as for the linked list component of the library. An association may be removed with <a class="el" href="group__dbprim__smat.html#a11">st_remove()</a>, or looked up with <a class="el" href="group__dbprim__smat.html#a12">st_find()</a>. If iteration over all associations is desired, use the <a class="el" href="group__dbprim__smat.html#a13">st_iter()</a> function. Removing all associations from a table may be performed with <a class="el" href="group__dbprim__smat.html#a14">st_flush()</a>, which optionally calls a user-defined clean-up function. The associated hash table may be resized with <a class="el" href="group__dbprim__smat.html#a15">st_resize()</a>, and the bucket table may be released with <a class="el" href="group__dbprim__smat.html#a16">st_free()</a>.<p>
An association may also be reordered within the linked lists using the <a class="el" href="group__dbprim__smat.html#a18">sh_move()</a> function. If a particular entry is desired, use the <a class="el" href="group__dbprim__smat.html#a19">sh_find()</a> function with a user-defined comparison function to locate it. Iteration may be performed with the <a class="el" href="group__dbprim__smat.html#a20">sh_iter()</a> function, and all entries in a given linked list may be removed with the sh_flush() function, which again may optionally call a user-defined clean-up function. 
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a21">st_verify</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table verification macro. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a22">st_flags</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table flags. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a23">st_frozen</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a sparse matrix is frozen. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a24">st_modulus</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table modulus. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a25">st_count</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table count. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a26">st_extra</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extra pointer data in a sparse matrix table. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a27">st_size</a>(table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table memory size. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a28">SMAT_HEAD_INIT</a>(elem, object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list head static initializer. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a29">sh_verify</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list head verification macro. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a30">sh_elem</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list head element macro. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a31">sh_table</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list head table pointer. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a32">sh_frozen</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a sparse matrix is frozen. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a33">sh_count</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list count. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a34">sh_first</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First element in sparse matrix list. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a35">sh_last</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last element in sparse matrix list. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a36">sh_object</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object represented by a sparse matrix list head. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a37">sh_size</a>(head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list memory size. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a38">se_verify</a>(entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix entry verification macro. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a39">se_table</a>(entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix entry table. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a41">se_flags</a>(entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix entry flags. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a42">se_hash</a>(entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table entry hash value. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a43">se_next</a>(entry, n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next element in sparse matrix list. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a44">se_prev</a>(entry, n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Previous element in sparse matrix list. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a45">se_lflags</a>(entry, n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags associated with an entry in a sparse matrix list. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a46">se_object</a>(entry, n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object associated with an entry in a sparse matrix list. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef _smat_table_s&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef _smat_head_s&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix list head. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef _smat_entry_s&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix entry. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef unsigned long(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a3">smat_resize_t</a> )(<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *, unsigned long)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix table resize callback. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef unsigned long(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> )(<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *, void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix iteration callback. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef unsigned long(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> )(<a class="el" href="dbprim_8h.html#a0">db_key_t</a> *, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix comparison callback. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="group__dbprim__smat.html#a47">_smat_loc_e</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix location. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a47">_smat_loc_e</a> { <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a>, 
<a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sparse matrix location. </em> <a href="#a47">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a7">smat_cleanup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up the smat free list. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a8">smat_freemem</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report how much memory is used by the free list. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a9">st_init</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, unsigned long flags, <a class="el" href="dbprim_8h.html#a3">smat_resize_t</a> resize, void *extra, unsigned long init_mod)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a10">st_add</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **entry_p, <a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head1, <a class="el" href="dbprim_8h.html#a4">link_loc_t</a> loc1, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *ent1, <a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head2, <a class="el" href="dbprim_8h.html#a4">link_loc_t</a> loc2, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *ent2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an entry to a sparse matrix. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a11">st_remove</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry from a sparse matrix. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a12">st_find</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **entry_p, <a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head1, <a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an entry in a sparse matrix. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a13">st_iter</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, <a class="el" href="dbprim_8h.html#a4">smat_iter_t</a> iter_func, void *extra)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over each entry in a sparse matrix. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a14">st_flush</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, <a class="el" href="dbprim_8h.html#a4">smat_iter_t</a> flush_func, void *extra)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a sparse matrix. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a15">st_resize</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table, unsigned long new_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize a sparse matrix table. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a16">st_free</a> (<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory used by an empty sparse matrix table. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a17">sh_init</a> (<a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head, <a class="el" href="dbprim_8h.html#a6">smat_loc_t</a> elem, void *object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically initialize a sparse matrix row or column head. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a18">sh_move</a> (<a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *elem, <a class="el" href="dbprim_8h.html#a4">link_loc_t</a> loc, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *elem2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move an entry within a row or column list. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a19">sh_find</a> (<a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **elem_p, <a class="el" href="dbprim_8h.html#a5">smat_comp_t</a> comp_func, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *start, <a class="el" href="dbprim_8h.html#a0">db_key_t</a> *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an entry in a row or column of a sparse matrix. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>unsigned long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__dbprim__smat.html#a20">sh_iter</a> (<a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *head, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *start, <a class="el" href="dbprim_8h.html#a4">smat_iter_t</a> iter_func, void *extra, unsigned long flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over each entry in a row or column of a sparse matrix. </em> <a href="#a20"></a><em><br><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a41" doxytag="dbprim.h::se_flags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_flags</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a set of user-defined flags associated with the entry. It may be used as an lvalue to set those flags.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing the flags associated with the entry. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="dbprim.h::se_hash" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_hash</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the hash value of the given sparse matrix entry. If the sparse matrix hash been resized, this value may not be the same as a previous value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing the hash code for the entry. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="dbprim.h::se_lflags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_lflags</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>n&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a set of user-defined flags associated with the entry in a sparse matrix list. It may be used as an lvalue to set those flags.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>One of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> to specify which list thread is desired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing the flags associated with the entry. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="dbprim.h::se_next" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_next</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>n&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the <a class="el" href="group__dbprim__link.html#a1">link_elem_t</a> for the next element in the sparse matrix list.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>entry</code> and <code>n</code> arguments twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>One of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> to specify which list thread is desired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="dbprim.h::se_object" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_object</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>n&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to one of the objects represented by the entry. It may be used as an lvalue to change the object pointed to. Care should be taken when using this feature.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>One of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> to specify which list thread is desired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <code>void</code> representing the object. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="dbprim.h::se_prev" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_prev</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>n&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the <a class="el" href="group__dbprim__link.html#a1">link_elem_t</a> for the previous element in the sparse matrix list.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>entry</code> and <code>n</code> arguments twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>One of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> to specify which list thread is desired.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="dbprim.h::se_table" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_table</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the table that the sparse matrix entry is in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="dbprim.h::se_verify" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define se_verify</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">entry&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro verifies that a given pointer actually does point to a sparse matrix entry.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>entry</code> argument twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean true if <code>entry</code> is a valid sparse matrix entry or false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="dbprim.h::sh_count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_count</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the number of elements in the sparse matrix list rooted at <code>head</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing a count of the number of elements in the sparse matrix list. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="dbprim.h::sh_elem" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_elem</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the position indicator for the sparse matrix head. It will return one of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="dbprim.h::sh_first" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_first</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> for the first element in the sparse matrix list.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>head</code> argument twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="dbprim.h::sh_frozen" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_frozen</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="dbprim.h::sh_last" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_last</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> for the last element in the sparse matrix list.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>head</code> argument twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="dbprim.h::sh_object" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_object</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves a pointer to the object referenced by the sparse matrix list head.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <code>void</code>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="dbprim.h::sh_size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_size</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro returns the physical size of the memory allocated by the library for this sparse matrix list.<p>
<dl compact><dt><b>Note:</b></dt><dd>The <a class="el" href="group__dbprim__smat.html#a27">st_size()</a> macro already counts the memory for each list in the table. Summing the results of <a class="el" href="group__dbprim__smat.html#a37">sh_size()</a> and <a class="el" href="group__dbprim__smat.html#a27">st_size()</a> will over-count the amount of memory actually in use.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A <code>size_t</code>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="dbprim.h::sh_table" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_table</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If there are any elements in this sparse matrix list head, this macro will retrieve a pointer to the table in which they reside.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="dbprim.h::sh_verify" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sh_verify</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">head&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro verifies that a given pointer actually does point to a sparse matrix head.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>head</code> argument twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean true if <code>head</code> is a valid sparse matrix head or false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="dbprim.h::SMAT_HEAD_INIT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SMAT_HEAD_INIT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">elem,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>object&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro statically initializes a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>elem</em>&nbsp;</td><td>One of <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> specifing whether the object is a member of the set of rows or columns. </td></tr>
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A pointer to <code>void</code> representing the object associated with the list head. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="dbprim.h::st_count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_count</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the total number of items actually in the sparse matrix table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing a count of the number of items in the sparse matrix table. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="dbprim.h::st_extra" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_extra</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the extra pointer data associated with a particular sparse matrix table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <code>void</code>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="dbprim.h::st_flags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_flags</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the flags associated with the sparse matrix table. Only <a class="el" href="group__dbprim__hash.html#a16">HASH_FLAG_AUTOGROW</a> and <a class="el" href="group__dbprim__hash.html#a17">HASH_FLAG_AUTOSHRINK</a> have any meaning to the application; all other bits are reserved for use in the library. This macro may be used as an lvalue, but care must be taken to avoid modifying the library-specific bits.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing the flags for the sparse matrix table. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="dbprim.h::st_frozen" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_frozen</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="dbprim.h::st_modulus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_modulus</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro retrieves the number of buckets allocated for the sparse matrix table. An application may wish to save this value between invocations to avoid the overhead of growing the table while filling it with data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An <code>unsigned long</code> containing the number of buckets allocated for the sparse matrix table. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="dbprim.h::st_size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_size</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro returns the physical size of the memory allocated by the library for this sparse matrix table.<p>
<dl compact><dt><b>Note:</b></dt><dd>The <a class="el" href="group__dbprim__smat.html#a27">st_size()</a> macro already counts the memory for each list in the table. Summing the results of <a class="el" href="group__dbprim__smat.html#a37">sh_size()</a> and <a class="el" href="group__dbprim__smat.html#a27">st_size()</a> will over-count the amount of memory actually in use.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A <code>size_t</code>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="dbprim.h::st_verify" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define st_verify</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">table&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro verifies that a given pointer actually does point to a sparse matrix table.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This macro may evaluate the <code>table</code> argument twice.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean true if <code>table</code> is a valid sparse matrix table or false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a5" doxytag="dbprim.h::smat_comp_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned long(* <a class="el" href="dbprim_8h.html#a5">smat_comp_t</a>)(<a class="el" href="dbprim_8h.html#a0">db_key_t</a> *, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function pointer references a callback used by <a class="el" href="group__dbprim__smat.html#a19">sh_find()</a>. It should return 0 if the sparse matrix entry represented by the second argument matches the key passed as the first argument.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="dbprim.h::smat_entry_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct _smat_entry_s <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This structure is allocated by the library and represents a single element in a sparse matrix.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="dbprim.h::smat_head_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct _smat_head_s <a class="el" href="dbprim_8h.html#a1">smat_head_t</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This structure is the head of a linked list of sparse matrix entries.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="dbprim.h::smat_iter_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned long(* <a class="el" href="dbprim_8h.html#a4">smat_iter_t</a>)(<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *, <a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *, void *)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function pointer references a callback used by <a class="el" href="group__dbprim__smat.html#a13">st_iter()</a>, <a class="el" href="group__dbprim__smat.html#a14">st_flush()</a>, <a class="el" href="group__dbprim__smat.html#a20">sh_iter()</a>, and sh_flush(). It should return 0 for success. A non-zero return value will terminate the operation and will become the return value of the call.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="dbprim.h::smat_loc_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="group__dbprim__smat.html#a47">_smat_loc_e</a> <a class="el" href="dbprim_8h.html#a6">smat_loc_t</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
See the documentation for the enumeration <a class="el" href="group__dbprim__smat.html#a47">_smat_loc_e</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="dbprim.h::smat_resize_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef unsigned long(* <a class="el" href="dbprim_8h.html#a3">smat_resize_t</a>)(<a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *, unsigned long)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function pointer references a callback that will be called with both the old and new sparse matrix table sizes whenever a sparse matrix's hash table table is resized. It should return non-zero only when the resize should be inhibited.     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="dbprim.h::smat_table_t" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct _smat_table_s <a class="el" href="dbprim_8h.html#a0">smat_table_t</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This structure is the basis of all sparse matrices maintained by this library.     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a47" doxytag="dbprim.h::_smat_loc_e" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group__dbprim__smat.html#a47">_smat_loc_e</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This enumeration is used to specify whether an element is a row or column element. It should be referenced by the typedef <a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a>. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a47a135" doxytag="SMAT_LOC_FIRST" ></a>SMAT_LOC_FIRST</em>&nbsp;</td><td>
First entry (``row''). </td></tr>
<tr><td valign=top><em><a class="anchor" name="a47a136" doxytag="SMAT_LOC_SECOND" ></a>SMAT_LOC_SECOND</em>&nbsp;</td><td>
Second entry (``column''). </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a19" doxytag="sh_find.c::sh_find" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long sh_find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>elem_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a5">smat_comp_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>comp_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a0">db_key_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function iterates through the given row or column of a sparse matrix looking for an element that matches the given <code>key</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
    <tr><td valign=top><em>elem_p</em>&nbsp;</td><td>A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result pramater. <code>NULL</code> is an invalid value. </td></tr>
    <tr><td valign=top><em>comp_func</em>&nbsp;</td><td>A pointer to a comparison function used to compare the key to a particular entry. See the documentation for <a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> for more information. </td></tr>
    <tr><td valign=top><em>start</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing where in the row or column to start. If <code>NULL</code> is passed, the beginning of the row or column will be assumed. </td></tr>
    <tr><td valign=top><em>key</em>&nbsp;</td><td>A key to search for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td><code>start</code> is not in this row or column. </td></tr>
    <tr><td valign=top><em>DB_ERR_NOENTRY</em>&nbsp;</td><td>No matching entry was found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="sh_init.c::sh_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long sh_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a6">smat_loc_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>elem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>object</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function dynamically initializes a sparse matrix row or column linked list head. The <code>elem</code> argument specifies whether the object is to be associated with a <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> list or a <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> to be initialized. </td></tr>
    <tr><td valign=top><em>elem</em>&nbsp;</td><td>Either <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>. </td></tr>
    <tr><td valign=top><em>object</em>&nbsp;</td><td>A pointer to the object containing the sparse matrix row or column head.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An invalid argument was given. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="sh_iter.c::sh_iter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long sh_iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">smat_iter_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>iter_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>extra</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function iterates over a row or column of a sparse matrix, executing the given <code>iter_func</code> for each entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
    <tr><td valign=top><em>start</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing where in the row or column to start. If <code>NULL</code> is passed, the beginning of the row or column will be assumed. </td></tr>
    <tr><td valign=top><em>iter_func</em>&nbsp;</td><td>A pointer to a callback function used to perform user-specified actions on an entry in a row or column of a sparse matrix. <code>NULL</code> is an invalid value. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
    <tr><td valign=top><em>extra</em>&nbsp;</td><td>A <code>void</code> pointer that will be passed to <code>iter_func</code>. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>If <a class="el" href="group__dbprim.html#a4">DB_FLAG_REVERSE</a> is given, iteration will be done from the end of the list backwards towards the head.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td><code>start</code> is not in this row or column. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="sh_move.c::sh_move" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long sh_move </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">link_loc_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>loc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>elem2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function allows the specified entry to be shifted within the linked list describing the row or column. It is very similar to the <a class="el" href="group__dbprim__link.html#a7">ll_move()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>head</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
    <tr><td valign=top><em>elem</em>&nbsp;</td><td>A pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing the entry to be moved. </td></tr>
    <tr><td valign=top><em>loc</em>&nbsp;</td><td>A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be moved to. </td></tr>
    <tr><td valign=top><em>elem2</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another entry in the list if <code>loc</code> is <a class="el" href="group__dbprim__link.html#a26a133">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a134">LINK_LOC_AFTER</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_BUSY</em>&nbsp;</td><td><code>elem</code> and <code>elem2</code> are the same entry. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td><code>elem</code> or <code>elem2</code> are in a different row or column. </td></tr>
    <tr><td valign=top><em>DB_ERR_UNUSED</em>&nbsp;</td><td><code>elem</code> or <code>elem2</code> are not in any row or column. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="smat_freelist.c::smat_cleanup" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long smat_cleanup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function frees all smat_entry_t objects on the internal free list. It is always successful and returns 0.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="smat_freelist.c::smat_freemem" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long smat_freemem </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the amount of memory being used by the internal free list of smat_entry_t objects.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A number indicating the size, in bytes, of the memory allocated for smat_entry_t objects on the free list. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="st_add.c::st_add" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_add </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>entry_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">link_loc_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>loc1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">link_loc_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>loc2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function adds an entry to a sparse matrix. The entry is referenced in three different places, thus the complex set of arguments. This function will allocate a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> and return it through the <code>entry_p</code> result parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>entry_p</em>&nbsp;</td><td>A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result parameter. If <code>NULL</code> is passed, the addition will be performed and an appropriate error code returned. </td></tr>
    <tr><td valign=top><em>head1</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> representing a <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a> sparse matrix list. </td></tr>
    <tr><td valign=top><em>loc1</em>&nbsp;</td><td>A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be added for <code>head1</code>. </td></tr>
    <tr><td valign=top><em>ent1</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another element in the list represented by <code>head1</code> if <code>loc1</code> is <a class="el" href="group__dbprim__link.html#a26a133">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a134">LINK_LOC_AFTER</a>. </td></tr>
    <tr><td valign=top><em>head2</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> representing a <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a> sparse matrix list. </td></tr>
    <tr><td valign=top><em>loc2</em>&nbsp;</td><td>A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be added for <code>head2</code>. </td></tr>
    <tr><td valign=top><em>ent2</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another element in the list represented by <code>head2</code> if <code>loc2</code> is <a class="el" href="group__dbprim__link.html#a26a133">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a134">LINK_LOC_AFTER</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_BUSY</em>&nbsp;</td><td>One of the arguments is already in the table. </td></tr>
    <tr><td valign=top><em>DB_ERR_FROZEN</em>&nbsp;</td><td>The table is currently frozen. </td></tr>
    <tr><td valign=top><em>DB_ERR_NOTABLE</em>&nbsp;</td><td>The bucket table has not been allocated and automatic growth is not enabled. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td>One of the arguments was not in the proper table or list. </td></tr>
    <tr><td valign=top><em>DB_ERR_UNUSED</em>&nbsp;</td><td>One of the <code>ent</code> arguments is not presently in a list. </td></tr>
    <tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>&nbsp;</td><td>An unrecoverable error occurred while resizing the table. </td></tr>
    <tr><td valign=top><em>ENOMEM</em>&nbsp;</td><td>No memory could be allocated for the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> structure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="st_find.c::st_find" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_find </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>entry_p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a1">smat_head_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>head2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function looks up the entry matching the given <code>head1</code> and <code>head2</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>entry_p</em>&nbsp;</td><td>A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result parameter. If <code>NULL</code> is passed, the lookup will be performed and an appropriate error code returned. </td></tr>
    <tr><td valign=top><em>head1</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> initialized to <a class="el" href="group__dbprim__smat.html#a47a135">SMAT_LOC_FIRST</a>. </td></tr>
    <tr><td valign=top><em>head2</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> initialized to <a class="el" href="group__dbprim__smat.html#a47a136">SMAT_LOC_SECOND</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td>One or both of <code>head1</code> or <code>head2</code> are not referenced in this table. </td></tr>
    <tr><td valign=top><em>DB_ERR_NOENTRY</em>&nbsp;</td><td>No matching entry was found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="st_flush.c::st_flush" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_flush </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">smat_iter_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flush_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>extra</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function flushes a sparse matrix--that is, it removes each entry from the matrix. If a <code>flush_func</code> is specified, it will be called on the entry after it has been removed from the table, and may safely call <code>free()</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>flush_func</em>&nbsp;</td><td>A pointer to a callback function used to perform user-specified actions on an entry after removing it from the table. May be <code>NULL</code>. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
    <tr><td valign=top><em>extra</em>&nbsp;</td><td>A <code>void</code> pointer that will be passed to <code>iter_func</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_FROZEN</em>&nbsp;</td><td>The sparse matrix is frozen. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="st_free.c::st_free" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>table</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function releases the memory used by the bucket table of the empty hash table associated with a sparse matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An invalid argument was given. </td></tr>
    <tr><td valign=top><em>DB_ERR_FROZEN</em>&nbsp;</td><td>The table is frozen. </td></tr>
    <tr><td valign=top><em>DB_ERR_NOTEMPTY</em>&nbsp;</td><td>The table is not empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="st_init.c::st_init" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a3">smat_resize_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>resize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>extra</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>init_mod</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes a sparse matrix table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> to be initialized. </td></tr>
    <tr><td valign=top><em>flags</em>&nbsp;</td><td>A bit-wise OR of <a class="el" href="group__dbprim__hash.html#a16">HASH_FLAG_AUTOGROW</a> and <a class="el" href="group__dbprim__hash.html#a17">HASH_FLAG_AUTOSHRINK</a>. If neither behavior is desired, use 0. </td></tr>
    <tr><td valign=top><em>resize</em>&nbsp;</td><td>A <a class="el" href="group__dbprim__hash.html#a5">hash_resize_t</a> function pointer for determining whether resizing is permitted and/or for notification of the resize. </td></tr>
    <tr><td valign=top><em>extra</em>&nbsp;</td><td>Extra pointer data that should be associated with the sparse matrix table. </td></tr>
    <tr><td valign=top><em>init_mod</em>&nbsp;</td><td>An initial modulus for the table. This will presumably be extracted by <a class="el" href="group__dbprim__smat.html#a24">st_modulus()</a> in a previous invocation of the application. A 0 value is valid.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An invalid argument was given. </td></tr>
    <tr><td valign=top><em>ENOMEM</em>&nbsp;</td><td>Unable to allocate memory. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="st_iter.c::st_iter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_iter </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a4">smat_iter_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>iter_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>extra</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function iterates over every entry in a sparse matrix (in an unspecified order), executing the given <code>iter_func</code> on each entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>iter_func</em>&nbsp;</td><td>A pointer to a callback function used to perform user-specified actions on an entry in a sparse matrix. <code>NULL</code> is an invalid value. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
    <tr><td valign=top><em>extra</em>&nbsp;</td><td>A <code>void</code> pointer that will be passed to <code>iter_func</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_FROZEN</em>&nbsp;</td><td>The sparse matrix is frozen. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="st_remove.c::st_remove" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_remove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="dbprim_8h.html#a2">smat_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function removes the given entry from the specified sparse matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>entry</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> to be removed from the table.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An invalid argument was given. </td></tr>
    <tr><td valign=top><em>DB_ERR_WRONGTABLE</em>&nbsp;</td><td>Entry is not in this sparse matrix. </td></tr>
    <tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>&nbsp;</td><td>An unrecoverable error occurred while removing the entry from the table. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="st_resize.c::st_resize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long st_resize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="dbprim_8h.html#a0">smat_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>table</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>new_size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function resizes the hash table associated with a sparse matrix based on the <code>new_size</code> parameter. See the documentation for <a class="el" href="group__dbprim__hash.html#a13">ht_resize()</a> for more information.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>table</em>&nbsp;</td><td>A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
    <tr><td valign=top><em>new_size</em>&nbsp;</td><td>A new size value for the table.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>DB_ERR_BADARGS</em>&nbsp;</td><td>An argument was invalid. </td></tr>
    <tr><td valign=top><em>DB_ERR_FROZEN</em>&nbsp;</td><td>The table is currently frozen. </td></tr>
    <tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>&nbsp;</td><td>A catastrophic error was encountered. The table is now unusable. </td></tr>
    <tr><td valign=top><em>ENOMEM</em>&nbsp;</td><td>No memory could be allocated for the new bucket table. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Sep 25 10:13:17 2004 for Database Primitives Library by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
